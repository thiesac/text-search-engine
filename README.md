# Text Search Engine 

## Project Overview

This project was developed as part of my studies at Trybe and it aims to simulate a document indexing algorithm similar to Google's. The program is designed to identify occurrences of terms in TXT files. The implementation consists of two modules:

1. **File Management Module:**
   - Manages text files (TXT format) by providing functions to attach and handle files.

2. **Search Module:**
   - Enables search operations on the attached files.

üëÄ This project focuses on file indexing, and it does not include features for analyzing meanings or searching for synonyms.

üöµ Skills Practiced:

- Stack Manipulation
- Deque Manipulation
- Node & Linked Lists Manipulation
- Doubly Linked Lists Manipulation

## Table of Contents

- [Project Details](#project-details)
- [Installation](#installation)
- [Contributing](#contributing)

# Project Details

## Challenge 1: File Queue Implementation
In this task, I implemented a queue to store files that would be read. The `Queue` class in the `queue.py` file was filled, utilizing data structures learned in the module. The queue operates as a FIFO structure, ensuring that the first item to enter is the first to exit. The implementation includes methods for insertion (`enqueue`), removal (`dequeue`), and search (`search`). The queue's size is exposed using the `__len__` method, enabling the use of `len(instance_of_queue)` to obtain the queue's size. The search method raises an `IndexError` with the message "√çndice Inv√°lido ou Inexistente" for invalid indices. The evaluator checks for proper queue functionality, size exposure, and error handling for invalid index access.

## Challenge 2: Text Importer Function
The second challenge involved implementing a `txt_importer` function within the `file_management` module. This function is capable of importing news from a TXT file using "\n" as a separator. Error messages are displayed to stderr if the TXT file does not exist or if the file extension is not `.txt`. The function returns a list containing the lines of the file. The evaluator checks for correct reading of TXT files, proper error messages, and the correct return type.

## Challenge 3: File Processing
In the third challenge, the task was to implement the `process` function in the `file_process` module. This function transforms the content of the list generated by the `txt_importer` function into a dictionary, which is then stored within the queue. The function receives an instantiated queue object and the path to a file as parameters. The queue instance is utilized to register the processing of files. The function processes the file, generating a dictionary with specific information, ignoring files processed previously. After each valid insertion, the function displays processed data via stdout. The evaluator checks for correct processing, handling of duplicate files, and proper output structure.

## Challenge 4: File Removal Function
For the fourth challenge, I implemented the `remove` function within the `file_process` module. This function removes the first processed file from the queue. The function receives the implemented queue as a parameter. If there are no files in the queue, the function emits the message "N√£o h√° elementos" via stdout. In case of successful removal, the function emits the message "Arquivo {path_file} removido com sucesso" via stdout, where {path_file} is the path of the removed file. The evaluator checks for proper handling of removal scenarios and correct messaging.

## Challenge 5: File Metadata Function
In the fifth challenge, the task was to implement the `file_metadata` function within the `file_process` module. This function presents superficial information about a processed file based on the specified index. The function receives the implemented queue and the index to be searched as parameters. The function handles scenarios where the position does not exist by emitting the error message "Posi√ß√£o inv√°lida" via stderr. If the position is valid, the function displays file-related information via stdout, following the example output structure. The evaluator checks for proper handling of index scenarios and correct output structure.

## Challenge 6: PriorityQueue Tests
For the sixth challenge, I implemented tests for the `PriorityQueue` class, which is capable of storing small files with priority. The `PriorityQueue` utilizes the implementation of the `Queue` class from the first challenge. Files with less than 5 lines are prioritized in the queue, impacting the results of the `dequeue` and `search` methods. The tests ensure that the logic of priorities is respected by the `enqueue`, `dequeue`, and `search` methods. The evaluator checks for proper testing of each method, priority logic validation, and correct exception handling.

## Challenge 7: Word Existence Search
In the seventh challenge, I implemented the `exists_word` function within the `word_search` module. This function checks the existence of a word in all processed files. The function receives the word to be searched and the implemented queue as parameters. It returns a list with information about each file and its lines where the word was found. The search is case-insensitive, and if the word is not found in any file, an empty list is returned. The queue remains unchanged during the search, preserving the same files before and after the operation. The evaluator checks for correct handling of word search scenarios, case-insensitivity, and maintaining queue integrity.

## Installation

To run this project, follow these steps:

1. Clone the repository to your local machine.
   ```bash
   git clone https://github.com/your-username/your-repo.git
   ```
2. Navigate to the project directory.
```
bash
Copy code
cd your-repo
```
4. Install any required dependencies.
```
bash
Copy code
pip install -r requirements.txt
```

## Contributing

If you'd like to contribute to the project or provide feedback, follow these steps:

1. Fork the project.
2. Create your feature branch (`git checkout -b feature/YourFeature`).
3. Commit your changes (`git commit -m 'Add some feature'`).
4. Push to the branch (`git push origin feature/YourFeature`).
5. Open a pull request or reach out with your feedback.

I appreciate your contributions and value your feedback!

